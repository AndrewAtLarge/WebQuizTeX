r'''
-----------------------------------------------------------------------------
    webquiz_xml | xml reader for reading the xml file generated by tex4ht
-----------------------------------------------------------------------------

    Copyright (C) Andrew Mathas and Donald Taylor, University of Sydney

    Distributed under the terms of the GNU General Public License (GPL)
                  http://www.gnu.org/licenses/

    This file is part of the Math_quiz system.

    <Andrew.Mathas@sydney.edu.au>
    <Donald.Taylor@sydney.edu.au>
-----------------------------------------------------------------------------
'''

# -*- encoding: utf-8 -*-

import sys
import xml.sax

# imports of webquiz code
from webquiz_util import debugging, metadata, webquiz_error

# ---------------------------------------------------------------------------------------
def ReadWebQuizXmlFile(quizfile, defaults):
    r'''
    Set up, call and then return the xml parser
    for the quiz web page
    '''
    parser = xml.sax.make_parser()
    quiz = QuizHandler(defaults)
    parser.setContentHandler(quiz)
    parser.setErrorHandler(quiz)
    parser.setDTDHandler(quiz) # as far as I can see this does nothing...
    parser.parse(quizfile)
    parser.close()
    return quiz


# ---------------------------------------------------------------------------------------
class Data(object):
    r'''
    A wrapper object class that holds the data for the different
    components of the quiz.
    '''
    def __init__(self, **args):
        '''
        Accepts key-value pairs, each of which is stored as an attribute
        '''
        self._items = args.items()
        for key, val in args.items():
            setattr(self, key, val)

    def __str__(self):
        r'''
        A string method, purely for debugging purposes...
        '''
        return '\n - '.join('{} = {}'.format(k, getattr(self, k)) for k in self._items)


class QuizHandler(xml.sax.ContentHandler):
    """
        The content handler gives the xml tags to `startElement`, which
        initialises the webquiz tags, and then `endElement` attaches the
        content of each webquiz tag tothe appropriate part of `self`. Any end
        tag that is ot special to webquiz has its contents appended to
        `self.text`. Any tag that contains `deFAULT` is set to the system
        default using the `defaults` dictionary.
    """

    def __init__(self, defaults):
        self.defaults = defaults

        # arrays for the different quiz components
        self.discussion_list = []
        self.question_list = []
        self.quiz_index = []

        # these will contain the link and meta elements from the xml file but they
        # are ignored by webquiz.py
        self.link_list = []
        self.meta_list = []

        # to add mathjs when an eval comparison is used
        self.mathjs = False  

        # the following tags have defaults set by `defaults`
        self.setting_tags = [
               'department',
               'department_url',
               'institution',
               'institution_url',
               'language',
               'theme',
        ]
        # quiz data
        for tag in self.setting_tags:
            setattr(self, tag, defaults[tag])
        self.breadcrumb = ''
        self.text = ''
        self.after_text = ''
        self.title = ''
        self.unit_code = ''
        self.unit_name = ''

        # keep track of current tags for debugging...
        self.current_tags=[]


    def set_default_attribute(self, key, value):
        ''' Set the attribute `key` of self, using the default value if
        `value=='deFAULT'`.
        '''
        if value.strip() == 'deFAULT':
            setattr(self, key, self.defaults[key])
        else:
            setattr(self, key, value)
        debugging('Just set "{}" equal to "{}" from "{}"'.format(key, getattr(self, key), value))

    def startElement(self, tag, attributes):
        '''
            At the start of each webquiz xml tag we need to pull out the
            attributes and place
        '''

        self.current_tags.append(tag)

        # initialise the quiz
        if tag == 'webquiz':
            for key in attributes.keys():
                self.set_default_attribute(key, attributes.get(key))

            # convert the following attibutes to booleans
            for key in ['debugging', 'hide_side_menu', 'one_page', 'pst2pdf', 'random_order']:
                setattr(self, key, getattr(self, key)=='true')

            # set debugging mode from the latex file...from this point on
            metadata.debugging = metadata.debugging or self.debugging

        # set up links, meta tags and department and unit data
        elif tag == 'link':
            self.link_list.append({key: attributes.get(key) for key in attributes.keys()})

        elif tag == 'meta':
            self.meta_list.append({key: attributes.get(key) for key in attributes.keys()})

        elif tag in ['department', 'institution', 'uni']:
            for key in attributes.keys():
                self.set_default_attribute(tag, attributes.get(key))

        elif tag == 'breadcrumb':
            self.set_default_attribute('breadcrumbs', attributes.get('breadcrumbs'))

        elif tag == 'unit_name':
            self.set_default_attribute('unit_url', attributes.get('url'))
            self.quizzes_url = attributes.get('quizzes_url')
            if self.quizzes_url == 'deFAULT':
                self.quizzes_url = self.unit_url + '/Quizzes'

        # set up questions and discussion
        elif tag == 'discussion':
            discussion = Data(heading = '',
                              short_heading = '',
                              text = ''  # The text of the discussion
            )
            self.discussion_list.append(discussion)

        elif tag == 'question':
            self.question_list.append(
                Data(text = '',      # The text of the question
                    type = None,    # input, or single or multiple choice
                    after_text = '' # text at end of question
                )
            )

        # process the different question types, items choice and responses
        elif tag == 'answer':
            if self.question_list[-1].type != None:
                webquiz_error('question {} has too many question types: {} and input'.format(
                        len(self.question_list)+1, self.question_list[-1].type)
                )
            self.question_list[-1].type = 'input'
            self.question_list[-1].answer = ''
            self.question_list[-1].when_right = ''
            self.question_list[-1].when_wrong = ''
            self.question_list[-1].text += self.text
            self.text = ''

            self.question_list[-1].comparison = attributes.get('comparison')
            self.question_list[-1].prompt = attributes.get('prompt')=='true'
            if self.question_list[-1].comparison in ['complex', 'number']:
                self.mathjs = True

        elif tag == 'choice':
            if self.question_list[-1].type != None:
                webquiz_error('question {} has too many question types: {} and choice'.format(
                        len(self.question_list)+1, self.question_list[-1].type)
                )
            self.question_list[-1].type = attributes.get('type')
            self.question_list[-1].columns = int(attributes.get('columns'))
            self.question_list[-1].items = []
            self.question_list[-1].correct = 0
            self.question_list[-1].text += self.text
            self.text = ''

        elif tag == 'item':
            self.question_list[-1].items.append(
                    Data(correct= attributes.get('correct'),
                         symbol=attributes.get('symbol'),
                         response='',
                         text=''
                        )
            )
            if attributes.get('correct')=='true':
                self.question_list[-1].correct += 1

        # finally look after the index file
        elif tag == 'index_item':
            self.quiz_index.append(Data(
                    prompt=attributes.get('prompt')=='true',
                    url=attributes.get('url'),
                    title=''
                )
            )

        elif tag == 'when':
            if self.text.strip() != '':
                self.question_list[-1].after_text += ' '+self.text.strip()
                debugging('After_text is now {}'.format(self.question_list[-1].after_text))
                self.text = ''
            self.current_tags[-1] = 'when_'+attributes.get('type')


    def endElement(self, tag):
        debugging('popping '+self.current_tags.pop()) # remove the last tag from the tag list

        text_used = True # assume that we will use the text

        if tag in self.setting_tags:
            self.set_default_attribute(tag, self.text)

        elif tag == 'answer':
            self.question_list[-1].answer = self.text.strip()

        elif tag == 'discussion':
            self.discussion_list[-1].text = self.text.strip()

        elif tag in ['heading', 'short_heading']:
            setattr(self.discussion_list[-1], tag, self.text.strip())

        elif tag =='item':
            self.question_list[-1].items[-1].text = self.text.strip()

        elif tag =='response':
            self.question_list[-1].items[-1].response = self.text.strip()

        elif tag == 'question':
            # some error checking
            if self.question_list[-1].type == None:
                    webquiz_error('question {} does have not an \answer or multiple choice'.format(
                                  len(self.question_list)+1))

            elif hasattr(self.question_list[-1], 'items'):
                if len(self.question_list[-1].items)==0:
                    webquiz_error('question {} has no multiple choice items'.format(
                                  len(self.question_list)+1))

                if self.question_list[-1].type=='single' and self.question_list[-1].correct!=1:
                    webquiz_error('question {} is single-choice but has {} correct answers'.format(
                                    len(self.question_list)+1,
                                    self.question_list[-1].correct
                                 )
                    )
            elif not hasattr(self.question_list[-1], 'answer') or self.question_list[-1].answer=='':
                webquiz_error('question {} does have not an \answer or multiple choice'.format(
                              len(self.question_list)+1))

            if self.text.strip() != '':
                self.question_list[-1].after_text += ' '+self.text.strip()

        elif tag in ['breadcrumb', 'title', 'unit_code', 'unit_name']:
            setattr(self, tag, self.text.strip())

        elif tag.startswith('when'):
            setattr(self.question_list[-1], tag, self.text.strip())

        elif tag == 'index_item':
            # ungainly hack to remove line breaks from titles...
            self.quiz_index[-1].title = self.text.strip().replace('\n',' ').replace('\r',' ')

        else:
            # mark that we still need to use the text
            text_used = False

        if text_used:
            self.text = ''

    def characters(self, text):  #data,start,length):
        r'''
        Append everything to `self.text`
        '''
        self.text += text

    def error(self, e):
        raise e

    def fatalError(self, e):
        raise e
